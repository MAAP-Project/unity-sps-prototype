
Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # helm_release.grq2-es will be created
  + resource "helm_release" "grq2-es" {
      + atomic                     = false
      + chart                      = "elasticsearch"
      + cleanup_on_fail            = false
      + create_namespace           = false
      + dependency_update          = false
      + disable_crd_hooks          = false
      + disable_openapi_validation = false
      + disable_webhooks           = false
      + force_update               = false
      + id                         = (known after apply)
      + lint                       = false
      + manifest                   = (known after apply)
      + max_history                = 0
      + metadata                   = (known after apply)
      + name                       = "grq2-es"
      + namespace                  = "unity-sps"
      + recreate_pods              = false
      + render_subchart_notes      = true
      + replace                    = false
      + repository                 = "https://helm.elastic.co"
      + reset_values               = false
      + reuse_values               = false
      + skip_crds                  = false
      + status                     = "deployed"
      + timeout                    = 150
      + values                     = [
          + <<-EOT
                ---
                clusterName: "grq-es"
                
                # Permit co-located instances for solitary minikube virtual machines.
                antiAffinity: "soft"
                
                # Shrink default JVM heap.
                esJavaOpts: "-Xmx512m -Xms512m"
                
                # Allocate smaller chunks of memory per pod.
                resources:
                  requests:
                    cpu: "1000m"
                    memory: "2Gi"
                  limits:
                    cpu: "1000m"
                    memory: "2Gi"
                
                # Request smaller persistent volumes.
                volumeClaimTemplate:
                  accessModes: ["ReadWriteOnce"]
                  storageClassName: "hostpath"
                  resources:
                    requests:
                      storage: 5Gi
                
                # elasticsearch:
                masterService: "grq-es"
                
                # because we're using 1 node the cluster health will be YELLOW instead of GREEN after data is ingested
                clusterHealthCheckParams: "wait_for_status=yellow&timeout=1s"
                
                replicas: 1
                
                service:
                  type: "LoadBalancer"
                
                httpPort: 9201
                transportPort: 9301
                
                esConfig:
                  elasticsearch.yml: |
                    http.cors.enabled : true
                    http.cors.allow-origin: "*"
                    http.port: 9201
                
                lifecycle:
                  postStart:
                    exec:
                      command:
                        - bash
                        - -c
                        - |
                          #!/bin/bash
                          ES_URL=http://localhost:9201
                          while [[ "$(curl -s -o /dev/null -w '%{http_code}\n' $ES_URL)" != "200" ]]; do sleep 1; done
                
                          grq_es_template=$(curl -s https://raw.githubusercontent.com/hysds/grq2/develop/config/es_template.json)
                          template=$(echo ${grq_es_template} | sed 's/{{ prefix }}/grq/;s/{{ alias }}/grq/')
                          curl -X PUT "$ES_URL/_template/grq" -H 'Content-Type: application/json' -d "${template}"
                
                          ingest_pipeline=$(curl -s https://raw.githubusercontent.com/hysds/grq2/develop/config/ingest_pipeline.json)
                          curl -X PUT "$ES_URL/_ingest/pipeline/dataset_pipeline" -H 'Content-Type: application/json' -d "${ingest_pipeline}"
            EOT,
        ]
      + verify                     = false
      + version                    = "7.9.3"
      + wait                       = true
      + wait_for_jobs              = false
    }

  # helm_release.mozart-es will be created
  + resource "helm_release" "mozart-es" {
      + atomic                     = false
      + chart                      = "elasticsearch"
      + cleanup_on_fail            = false
      + create_namespace           = false
      + dependency_update          = false
      + disable_crd_hooks          = false
      + disable_openapi_validation = false
      + disable_webhooks           = false
      + force_update               = false
      + id                         = (known after apply)
      + lint                       = false
      + manifest                   = (known after apply)
      + max_history                = 0
      + metadata                   = (known after apply)
      + name                       = "mozart-es"
      + namespace                  = "unity-sps"
      + recreate_pods              = false
      + render_subchart_notes      = true
      + replace                    = false
      + repository                 = "https://helm.elastic.co"
      + reset_values               = false
      + reuse_values               = false
      + skip_crds                  = false
      + status                     = "deployed"
      + timeout                    = 150
      + values                     = [
          + <<-EOT
                ---
                clusterName: "mozart-es"
                
                # Permit co-located instances for solitary minikube virtual machines.
                antiAffinity: "soft"
                
                # Shrink default JVM heap.
                esJavaOpts: "-Xmx512m -Xms512m"
                
                # Allocate smaller chunks of memory per pod.
                resources:
                  requests:
                    cpu: "1000m"
                    memory: "2Gi"
                  limits:
                    cpu: "1000m"
                    memory: "2Gi"
                
                # Request smaller persistent volumes.
                volumeClaimTemplate:
                  accessModes: ["ReadWriteOnce"]
                  storageClassName: "hostpath"
                  resources:
                    requests:
                      storage: 5Gi
                
                # elasticsearch:
                masterService: "mozart-es"
                
                # because we're using 1 node the cluster health will be YELLOW instead of GREEN after data is ingested
                clusterHealthCheckParams: "wait_for_status=yellow&timeout=1s"
                
                replicas: 1
                
                service:
                  type: "LoadBalancer"
                
                httpPort: 9200
                transportPort: 9300
                
                esConfig:
                  elasticsearch.yml: |
                    http.cors.enabled : true
                    http.cors.allow-origin: "*"
                
                lifecycle:
                  postStart:
                    exec:
                      command:
                        - bash
                        - -c
                        - |
                          #!/bin/bash
                          ES_URL=http://localhost:9200
                          while [[ "$(curl -s -o /dev/null -w '%{http_code}\n' $ES_URL)" != "200" ]]; do sleep 1; done
                          mozart_es_template=$(curl -s https://raw.githubusercontent.com/hysds/mozart/develop/configs/es_template.json)
                          for idx in "containers" "job_specs" "hysds_io"; do
                            template=$(echo ${mozart_es_template} | sed "s/{{ index }}/${idx}/")
                            curl -X PUT "$ES_URL/_template/${idx}" -H 'Content-Type: application/json' -d "${template}" >/dev/null
                          done
                
                          hysds_io_mozart=$(curl -s https://raw.githubusercontent.com/hysds/mozart/develop/configs/hysds_ios.mapping)
                          curl -X PUT "$ES_URL/_template/hysds_ios-mozart?pretty" -H 'Content-Type: application/json' -d '${hysds_io_mozart}'
                
                          user_rules_mozart=$(curl -s https://raw.githubusercontent.com/hysds/mozart/develop/configs/user_rules_job.mapping)
                          curl -X PUT "$ES_URL/user_rules-mozart?pretty" -H 'Content-Type: application/json' -d "${user_rules_mozart}"
                
                          hysds_io_grq=$(curl -s https://raw.githubusercontent.com/hysds/grq2/develop/config/hysds_ios.mapping)
                          curl -X PUT "$ES_URL/hysds_ios-grq?pretty"  -H 'Content-Type: application/json' -d "${hysds_io_grq}"
                
                          user_rules_grq=$(curl -s https://raw.githubusercontent.com/hysds/grq2/develop/config/user_rules_dataset.mapping)
                          curl -X PUT "$ES_URL/user_rules-grq?pretty" -H 'Content-Type: application/json' -d "${user_rules_grq}"
            EOT,
        ]
      + verify                     = false
      + version                    = "7.9.3"
      + wait                       = true
      + wait_for_jobs              = false
    }

  # kubernetes_config_map.aws-credentials will be created
  + resource "kubernetes_config_map" "aws-credentials" {
      + data = {
          + "aws-credentials" = <<-EOT
                [default]
                aws_access_key_id = hysds
                aws_secret_access_key = password
            EOT
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "aws-credentials"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_config_map.celeryconfig will be created
  + resource "kubernetes_config_map" "celeryconfig" {
      + data = {
          + "celeryconfig.py" = <<-EOT
                broker_url = "amqp://guest:guest@rabbitmq:5672//"
                result_backend = "redis://redis:6379"
                
                task_serializer = "msgpack"
                result_serializer = "msgpack"
                accept_content = ["msgpack"]
                
                task_acks_late = True
                result_expires = 86400
                worker_prefetch_multiplier = 1
                
                event_serializer = "msgpack"
                worker_send_task_events = True
                task_send_sent_event = True
                task_track_started = True
                
                task_queue_max_priority = 10
                
                task_reject_on_worker_lost = True
                
                broker_heartbeat = 120
                broker_heartbeat_checkrate = 2
                
                broker_pool_limit = None
                broker_transport_options = { "confirm_publish": True }
                
                imports = [
                    "hysds.task_worker",
                    "hysds.job_worker",
                    "hysds.orchestrator",
                ]
                
                CELERY_SEND_TASK_ERROR_EMAILS = False
                ADMINS = (
                    ('{{ ADMIN_NAME }}', '{{ ADMIN_EMAIL }}'),
                )
                SERVER_EMAIL = '{{ HOST_STRING }}'
                
                HYSDS_HANDLE_SIGNALS = False
                HYSDS_JOB_STATUS_EXPIRES = 86400
                
                BACKOFF_MAX_VALUE = 64
                BACKOFF_MAX_TRIES = 10
                
                HARD_TIME_LIMIT_GAP = 300
                
                PYMONITOREDRUNNER_CFG = {
                    "rabbitmq": {
                        "hostname": "{{ MOZART_RABBIT_PVT_IP }}",
                        "port": 5672,
                        "queue": "stdouterr"
                    },
                
                    "StreamObserverFileWriter": {
                        "stdout_filepath": "_stdout.txt",
                        "stderr_filepath": "_stderr.txt"
                    },
                
                    "StreamObserverMessenger": {
                        "send_interval": 1
                    }
                }
                
                MOZART_URL = "https://mozart:8888/mozart/"
                MOZART_REST_URL = "http://mozart:8888/api/v0.1"
                JOBS_ES_URL = "http://mozart-es:9200"
                JOBS_PROCESSED_QUEUE = "jobs_processed"
                USER_RULES_JOB_QUEUE = "user_rules_job"
                ON_DEMAND_JOB_QUEUE = "on_demand_job"
                USER_RULES_JOB_INDEX = "user_rules-mozart"
                STATUS_ALIAS = "job_status"
                
                TOSCA_URL = "https://{{ GRQ_PVT_IP }}/search/"
                GRQ_URL = "http://grq2:8878"
                GRQ_REST_URL = "http://grq2:8878/api/v0.1"
                GRQ_UPDATE_URL = "http://grq2:8878/api/v0.1/grq/dataset/index"
                
                
                GRQ_AWS_ES = False
                GRQ_ES_HOST = "grq-es"
                GRQ_ES_PORT = 9201
                GRQ_ES_PROTOCOL = "http"
                GRQ_ES_URL = '%s://%s:%d' % (GRQ_ES_PROTOCOL, GRQ_ES_HOST, GRQ_ES_PORT)
                
                
                DATASET_PROCESSED_QUEUE = "dataset_processed"
                USER_RULES_DATASET_QUEUE = "user_rules_dataset"
                ON_DEMAND_DATASET_QUEUE = "on_demand_dataset"
                USER_RULES_DATASET_INDEX = "user_rules-grq"
                DATASET_ALIAS = "grq"
                
                HYSDS_IOS_MOZART = "hysds_ios-mozart"
                HYSDS_IOS_GRQ = "hysds_ios-grq"
                
                USER_RULES_TRIGGER_QUEUE = "user_rules_trigger"
                
                PROCESS_EVENTS_TASKS_QUEUE = "process_events_tasks"
                
                METRICS_ES_URL = "http://{{ METRICS_ES_PVT_IP }}:9200"
                
                # REDIS_JOB_STATUS_URL = "redis://:{{ MOZART_REDIS_PASSWORD }}@{{ MOZART_REDIS_PVT_IP }}"
                REDIS_JOB_STATUS_URL = "redis://redis:6379"
                REDIS_JOB_STATUS_KEY = "logstash"
                REDIS_JOB_INFO_URL = "redis://redis:6379"
                REDIS_JOB_INFO_KEY = "logstash"
                REDIS_INSTANCE_METRICS_URL = "redis://:{{ METRICS_REDIS_PASSWORD }}@{{ METRICS_REDIS_PVT_IP }}"
                REDIS_INSTANCE_METRICS_KEY = "logstash"
                # REDIS_UNIX_DOMAIN_SOCKET = "unix://:{{ MOZART_REDIS_PASSWORD }}@/tmp/redis.sock"
                REDIS_UNIX_DOMAIN_SOCKET = "unix://:/tmp/redis.sock"
                
                WORKER_CONTIGUOUS_FAILURE_THRESHOLD = 10
                WORKER_CONTIGUOUS_FAILURE_TIME = 5.
                
                # ROOT_WORK_DIR = "/data/work"
                ROOT_WORK_DIR = "/private/tmp/data/work"
                WEBDAV_URL = None
                WEBDAV_PORT = 8085
                
                WORKER_MOUNT_BLACKLIST = [
                    "/dev",
                    "/etc",
                    "/lib",
                    "/proc",
                    "/usr",
                    "/var",
                ]
                
                CONTAINER_REGISTRY = "{{ CONTAINER_REGISTRY }}"
                
                AWS_REGION = "{{ AWS_REGION }}"
            EOT
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "celeryconfig"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_config_map.datasets will be created
  + resource "kubernetes_config_map" "datasets" {
      + data = {
          + "datasets.json" = jsonencode(
                {
                  + datasets = [
                      + {
                          + alt_match_pattern = null
                          + browse            = {
                              + location        = "s3://minio:9000/datasets/browse/{id}"
                              + s3-profile-name = "default"
                              + urls            = [
                                  + "http://localhost:9001/buckets/datasets/browse/products/{id}",
                                  + "s3://minio:9000/datasets/browse/{id}",
                                ]
                            }
                          + extractor         = null
                          + ipath             = "ariamh::data/area_of_interest"
                          + level             = "L0"
                          + match_pattern     = "/(?P<id>AOI_.+)$"
                          + publish           = {
                              + location        = "s3://minio:9000/datasets/products/{id}"
                              + s3-profile-name = "default"
                              + urls            = [
                                  + "http://localhost:9001/buckets/datasets/browse/products/{id}",
                                  + "s3://minio:9000/datasets/products/{id}",
                                ]
                            }
                          + type              = "area_of_interest"
                        },
                      + {
                          + alt_match_pattern = null
                          + browse            = {
                              + location        = "s3://minio:9000/datasets/browse/hello_world/{version}/{year}/{month}/{day}/{id}"
                              + s3-profile-name = "default"
                              + urls            = [
                                  + "http://localhost:9001/buckets/datasets/browse/products/hello_world/{version}/{year}/{month}/{day}/{id}",
                                  + "s3://minio:9000/datasets/browse/hello_world/{version}/{year}/{month}/{day}/{id}",
                                ]
                            }
                          + extractor         = null
                          + ipath             = "hysds::data/hello_world"
                          + level             = "NA"
                          + match_pattern     = "/(?P<id>hello_world-product-(?P<year>\\d{4})(?P<month>\\d{2})(?P<day>\\d{2})T.*)$"
                          + publish           = {
                              + location        = "s3://minio:9000/datasets/products/hello_world/{version}/{year}/{month}/{day}/{id}"
                              + s3-profile-name = "default"
                              + urls            = [
                                  + "http://localhost:9001/buckets/datasets/browse/products/hello_world/{version}/{year}/{month}/{day}/{id}",
                                  + "s3://minio:9000/datasets/products/hello_world/{version}/{year}/{month}/{day}/{id}",
                                ]
                            }
                          + type              = "hello_world"
                        },
                    ]
                }
            )
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "datasets"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_config_map.grq2-settings will be created
  + resource "kubernetes_config_map" "grq2-settings" {
      + data = {
          + "settings.cfg" = <<-EOT
                # ElasticSearch URL
                AWS_ES = False
                ES_PROTOCOL = "http"
                ES_HOST = "grq-es"
                ES_PORT = 9201
                # ES_URL = "{{ GRQ_ES_PROTOCOL or 'http' }}://{{ GRQ_ES_PVT_IP }}:{{ GRQ_ES_PORT or 9200}}"
                ES_URL = "http://grq-es:9201"
                
                # Mozart Elasticsearch URL
                MOZART_ES_URL = "http://mozart-es:9200"
                
                # alias to ElasticSearch GRQ index
                GRQ_INDEX = "grq"
                
                # ElasticSearch geonames index
                GEONAMES_INDEX = "geonames"
                
                # Redis URL
                REDIS_URL = "redis://redis:6379/0"
                
                # ES index for user rules (located in mozart's ES)
                USER_RULES_INDEX = "user_rules-grq"
                
                # ES index for hysds_ios and job_specs (located in mozart's ES)
                HYSDS_IOS_INDEX = "hysds_ios-grq"
                JOB_SPECS_INDEX = "job_specs"
                
                AWS_REGION = "{{ AWS_REGION }}"
            EOT
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "grq2-settings"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_config_map.logstash-configs will be created
  + resource "kubernetes_config_map" "logstash-configs" {
      + data = {
          + "event-status"  = jsonencode(
                {
                  + aliases        = {
                      + job_status = {}
                    }
                  + index_patterns = [
                      + "event_status*",
                    ]
                  + mappings       = {
                      + properties = {
                          + event       = {
                              + enabled = false
                              + type    = "object"
                            }
                          + hostname    = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + resource    = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + status      = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + tags        = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + fields  = {
                                  + keyword = {
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                }
                              + type    = "text"
                            }
                          + text_fields = {
                              + type = "text"
                            }
                          + timestamp   = {
                              + type = "date"
                            }
                          + type        = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + uuid        = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                        }
                    }
                  + settings       = {
                      + analysis               = {
                          + analyzer = {
                              + default = {
                                  + filter    = [
                                      + "lowercase",
                                      + "word_delimiter",
                                    ]
                                  + tokenizer = "keyword"
                                }
                            }
                        }
                      + index.refresh_interval = "5s"
                    }
                }
            )
          + "job-status"    = jsonencode(
                {
                  + aliases        = {
                      + job_status = {}
                    }
                  + index_patterns = [
                      + "job_status*",
                    ]
                  + mappings       = {
                      + properties = {
                          + celery_hostname  = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + celery_pid       = {
                              + type = "integer"
                            }
                          + celery_runtime   = {
                              + type = "double"
                            }
                          + celery_timestamp = {
                              + type = "date"
                            }
                          + context          = {
                              + enabled = false
                              + type    = "object"
                            }
                          + dedup            = {
                              + type = "boolean"
                            }
                          + dedup_job        = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + dedup_msg        = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + type    = "text"
                            }
                          + error            = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + fields  = {
                                  + keyword = {
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                }
                              + type    = "text"
                            }
                          + job              = {
                              + properties = {
                                  + command              = {
                                      + enabled = false
                                      + type    = "object"
                                    }
                                  + container_image_name = {
                                      + copy_to      = [
                                          + "text_fields",
                                        ]
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                  + container_image_url  = {
                                      + copy_to      = [
                                          + "text_fields",
                                        ]
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                  + context              = {
                                      + enabled = false
                                      + type    = "object"
                                    }
                                  + delivery_info        = {
                                      + properties = {
                                          + exchange    = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + priority    = {
                                              + type = "integer"
                                            }
                                          + redelivered = {
                                              + type = "boolean"
                                            }
                                          + routing_key = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                        }
                                    }
                                  + job_hash             = {
                                      + copy_to      = [
                                          + "text_fields",
                                        ]
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                  + job_id               = {
                                      + copy_to      = [
                                          + "text_fields",
                                        ]
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                  + job_info             = {
                                      + properties = {
                                          + cmd_duration        = {
                                              + type = "double"
                                            }
                                          + cmd_end             = {
                                              + type = "date"
                                            }
                                          + cmd_start           = {
                                              + type = "date"
                                            }
                                          + completed_queue     = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + context             = {
                                              + enabled = false
                                              + type    = "object"
                                            }
                                          + dedup               = {
                                              + type = "boolean"
                                            }
                                          + dedup_job           = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + duration            = {
                                              + type = "double"
                                            }
                                          + error_queue         = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + execute_node        = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + facts               = {
                                              + properties = {
                                                  + architecture                    = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + ec2_ami_id                      = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + ec2_instance_type               = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + ec2_placement_availability_zone = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + is_virtual                      = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + memorytotal                     = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + physicalprocessorcount          = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + processorcount                  = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + swapsize                        = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + virtual                         = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                }
                                            }
                                          + host                = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + id                  = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + job_dir             = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + job_payload         = {
                                              + properties = {
                                                  + job_type        = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + payload_task_id = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                }
                                            }
                                          + job_queue           = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + job_status_exchange = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + job_url             = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + metrics             = {
                                              + properties = {
                                                  + inputs_localized   = {
                                                      + properties = {
                                                          + disk_usage    = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + duration      = {
                                                              + type = "double"
                                                            }
                                                          + path          = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + time_end      = {
                                                              + type = "date"
                                                            }
                                                          + time_start    = {
                                                              + type = "date"
                                                            }
                                                          + transfer_rate = {
                                                              + type = "double"
                                                            }
                                                          + url           = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                        }
                                                    }
                                                  + job_dir_size       = {
                                                      + copy_to      = [
                                                          + "text_fields",
                                                        ]
                                                      + ignore_above = 256
                                                      + type         = "keyword"
                                                    }
                                                  + product_provenance = {
                                                      + properties = {
                                                          + access_latency         = {
                                                              + type = "double"
                                                            }
                                                          + acquisition_start_time = {
                                                              + type = "date"
                                                            }
                                                          + availability_time      = {
                                                              + type = "date"
                                                            }
                                                          + ground_system_latency  = {
                                                              + type = "double"
                                                            }
                                                          + location               = {
                                                              + strategy = "recursive"
                                                              + type     = "geo_shape"
                                                            }
                                                          + processing_latency     = {
                                                              + type = "double"
                                                            }
                                                          + processing_start_time  = {
                                                              + type = "date"
                                                            }
                                                          + product_type           = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + source_production_time = {
                                                              + type = "date"
                                                            }
                                                          + total_latency          = {
                                                              + type = "double"
                                                            }
                                                        }
                                                    }
                                                  + products_staged    = {
                                                      + properties = {
                                                          + browse_urls    = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + dataset        = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + dataset_level  = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + dataset_type   = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + disk_usage     = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + duration       = {
                                                              + type = "double"
                                                            }
                                                          + id             = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + ipath          = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + path           = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + system_version = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                          + time_end       = {
                                                              + type = "date"
                                                            }
                                                          + time_start     = {
                                                              + type = "date"
                                                            }
                                                          + transfer_rate  = {
                                                              + type = "double"
                                                            }
                                                          + urls           = {
                                                              + copy_to      = [
                                                                  + "text_fields",
                                                                ]
                                                              + ignore_above = 256
                                                              + type         = "keyword"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                          + payload             = {
                                              + enabled = false
                                              + type    = "object"
                                            }
                                          + payload_hash        = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + public_ip           = {
                                              + copy_to      = [
                                                  + "text_fields",
                                                ]
                                              + ignore_above = 256
                                              + type         = "keyword"
                                            }
                                          + status              = {
                                              + type = "integer"
                                            }
                                          + time_end            = {
                                              + type = "date"
                                            }
                                          + time_queued         = {
                                              + type = "date"
                                            }
                                          + time_start          = {
                                              + type = "date"
                                            }
                                        }
                                    }
                                  + localize_urls        = {
                                      + enabled = false
                                      + type    = "object"
                                    }
                                  + name                 = {
                                      + copy_to      = [
                                          + "text_fields",
                                        ]
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                  + params               = {
                                      + enabled = false
                                      + type    = "object"
                                    }
                                  + priority             = {
                                      + type = "integer"
                                    }
                                  + tag                  = {
                                      + copy_to      = [
                                          + "text_fields",
                                        ]
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                  + task_id              = {
                                      + copy_to      = [
                                          + "text_fields",
                                        ]
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                  + type                 = {
                                      + copy_to      = [
                                          + "text_fields",
                                        ]
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                  + username             = {
                                      + copy_to      = [
                                          + "text_fields",
                                        ]
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                }
                            }
                          + job_id           = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + msg              = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + msg_details      = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + payload_hash     = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + payload_id       = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + resource         = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + short_error      = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + fields  = {
                                  + keyword = {
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                }
                              + type    = "text"
                            }
                          + signum           = {
                              + type = "integer"
                            }
                          + status           = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + tags             = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + fields  = {
                                  + keyword = {
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                }
                              + type    = "text"
                            }
                          + text_fields      = {
                              + type = "text"
                            }
                          + timestamp        = {
                              + type = "date"
                            }
                          + traceback        = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + type    = "text"
                            }
                          + type             = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + user_tags        = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + fields  = {
                                  + keyword = {
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                }
                              + type    = "text"
                            }
                          + uuid             = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                        }
                    }
                  + settings       = {
                      + analysis               = {
                          + analyzer = {
                              + default = {
                                  + filter    = [
                                      + "lowercase",
                                      + "word_delimiter",
                                    ]
                                  + tokenizer = "keyword"
                                }
                            }
                        }
                      + index.refresh_interval = "5s"
                    }
                }
            )
          + "logstash-conf" = <<-EOT
                input {
                  redis {
                    host => "redis"
                    # {% if MOZART_REDIS_PASSWORD != "" %}password => "{{ MOZART_REDIS_PASSWORD }}"{% endif %}
                    # these settings should match the output of the agent
                    data_type => "list"
                    key => "logstash"
                
                    # We use the 'msgpack' codec here because we expect to read
                    # msgpack events from redis.
                    codec => msgpack
                  }
                }
                
                filter {
                  if [resource] in ["worker", "task"] {
                    mutate {
                      convert => {
                        "[event][timestamp]" => "string"
                        "[event][local_received]" => "string"
                      }
                
                      split => ["[event][timestamp]", "."]
                      split => ["[event][local_received]", "."]
                
                      add_field => [ "[event][timestamp_new]" , "%{[event][timestamp][0]}" ]
                      add_field => [ "[event][local_received_new]" , "%{[event][local_received][0]}" ]
                
                      remove_field => ["[event][timestamp]", "[event][local_received]"]
                    }
                
                    mutate {
                      rename => { "[event][timestamp_new]" => "timestamp" }
                      rename => { "[event][local_received_new]" => "local_received" }
                    }
                  }
                }
                
                output {
                  #stdout { codec => rubydebug }
                
                  if [resource] == "job" {
                    elasticsearch {
                      hosts => ["mozart-es:9200"]
                      index => "job_status-current"
                      document_id => "%{payload_id}"
                      template => "/usr/share/logstash/job_status.template.json"
                      template_name => "job_status"
                    }
                  } else if [resource] == "worker" {
                    elasticsearch {
                      hosts => ["mozart-es:9200"]
                      index => "worker_status-current"
                      document_id => "%{celery_hostname}"
                      template => "/usr/share/logstash/worker_status.template.json"
                      template_name => "worker_status"
                    }
                  } else if [resource] == "task" {
                    elasticsearch {
                      hosts => ["mozart-es:9200"]
                      index => "task_status-current"
                      document_id => "%{uuid}"
                      template => "/usr/share/logstash/task_status.template.json"
                      template_name => "task_status"
                    }
                  } else if [resource] == "event" {
                    elasticsearch {
                      hosts => ["mozart-es:9200"]
                      index => "event_status-current"
                      document_id => "%{uuid}"
                      template => "/usr/share/logstash/event_status.template.json"
                      template_name => "event_status"
                    }
                  } else {}
                }
            EOT
          + "logstash-yml"  = <<-EOT
                http.host: "0.0.0.0"
                xpack.monitoring.elasticsearch.hosts: ["http://mozart-es:9200"]
            EOT
          + "task-status"   = jsonencode(
                {
                  + aliases        = {
                      + job_status  = {}
                      + task_status = {}
                    }
                  + index_patterns = [
                      + "task_status*",
                    ]
                  + mappings       = {
                      + properties = {
                          + celery_hostname = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + type    = "text"
                            }
                          + event           = {
                              + properties = {
                                  + active         = {
                                      + type = "integer"
                                    }
                                  + clock          = {
                                      + type = "integer"
                                    }
                                  + freq           = {
                                      + type = "double"
                                    }
                                  + hostname       = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + loadavg        = {
                                      + type = "double"
                                    }
                                  + local_received = {
                                      + type = "date"
                                    }
                                  + pid            = {
                                      + type = "integer"
                                    }
                                  + processed      = {
                                      + type = "integer"
                                    }
                                  + sw_ident       = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + sw_sys         = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + sw_ver         = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + timestamp      = {
                                      + type = "date"
                                    }
                                  + type           = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + utcoffset      = {
                                      + type = "integer"
                                    }
                                }
                            }
                          + resource        = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + status          = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + tags            = {
                              + fields = {
                                  + keyword = {
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                }
                              + type   = "text"
                            }
                          + text_fields     = {
                              + type = "text"
                            }
                          + type            = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + uuid            = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + type    = "text"
                            }
                        }
                    }
                  + settings       = {
                      + analysis = {
                          + analyzer = {
                              + default = {
                                  + filter    = [
                                      + "lowercase",
                                      + "word_delimiter",
                                    ]
                                  + tokenizer = "keyword"
                                }
                            }
                        }
                    }
                }
            )
          + "worker-status" = jsonencode(
                {
                  + aliases        = {
                      + job_status    = {}
                      + worker_status = {}
                    }
                  + index_patterns = [
                      + "worker_status*",
                    ]
                  + mappings       = {
                      + properties = {
                          + celery_hostname = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + type    = "text"
                            }
                          + event           = {
                              + properties = {
                                  + active         = {
                                      + type = "integer"
                                    }
                                  + clock          = {
                                      + type = "integer"
                                    }
                                  + freq           = {
                                      + type = "double"
                                    }
                                  + hostname       = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + loadavg        = {
                                      + type = "double"
                                    }
                                  + local_received = {
                                      + type = "date"
                                    }
                                  + pid            = {
                                      + type = "integer"
                                    }
                                  + processed      = {
                                      + type = "integer"
                                    }
                                  + sw_ident       = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + sw_sys         = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + sw_ver         = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + timestamp      = {
                                      + type = "date"
                                    }
                                  + type           = {
                                      + copy_to = [
                                          + "text_fields",
                                        ]
                                      + type    = "text"
                                    }
                                  + utcoffset      = {
                                      + type = "integer"
                                    }
                                }
                            }
                          + resource        = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + status          = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + tags            = {
                              + fields = {
                                  + keyword = {
                                      + ignore_above = 256
                                      + type         = "keyword"
                                    }
                                }
                              + type   = "text"
                            }
                          + text_fields     = {
                              + type = "text"
                            }
                          + type            = {
                              + copy_to      = [
                                  + "text_fields",
                                ]
                              + ignore_above = 256
                              + type         = "keyword"
                            }
                          + uuid            = {
                              + copy_to = [
                                  + "text_fields",
                                ]
                              + type    = "text"
                            }
                        }
                    }
                  + settings       = {
                      + analysis = {
                          + analyzer = {
                              + default = {
                                  + filter    = [
                                      + "lowercase",
                                      + "word_delimiter",
                                    ]
                                  + tokenizer = "keyword"
                                }
                            }
                        }
                    }
                }
            )
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "logstash-configs"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_config_map.mozart-settings will be created
  + resource "kubernetes_config_map" "mozart-settings" {
      + data = {
          + "settings.cfg" = <<-EOT
                # secret key
                SECRET_KEY = "This is a test secret key"
                
                # ops account
                OPS_USER = "{{ OPS_USER }}"
                OPS_PASSWORD_HASH = "{{ OPS_PASSWORD_HASH }}"
                
                #LDAP
                LDAP_HOST = "ldap.test.com"
                LDAP_BASEDN = "ou=personnel,dc=dir,dc=test,dc=com"
                LDAP_GROUPS = "{{ LDAP_GROUPS }}"
                
                # PORT
                PORT = 8888
                
                # GRQ SERVER
                GRQ_HOST = "{{ GRQ_FQDN }}"
                GRQ_PORT = 80
                TOSCA_URL = "https://{{ GRQ_FQDN }}/search/"
                
                # Mozart URL
                MOZART_URL = "https://{{ MOZART_FQDN }}/mozart/"
                
                # Mozart REST API
                MOZART_REST_API = "https://{{ MOZART_PVT_IP }}/mozart/"
                
                # ElasticSearch host and indices
                ES_URL = "http://mozart-es:9200"
                USER_RULES_INDEX = "user_rules-mozart"
                HYSDS_IOS_INDEX = "hysds_ios-mozart"
                JOB_SPECS_INDEX = "job_specs"
                JOB_STATUS_INDEX = "job_status-current"
                CONTAINERS_INDEX = "containers"
                
                # key file for fabric
                KEY_FILENAME = "{{ KEY_FILENAME }}"
                
                # execute node user
                EXECUTE_NODE_USER = "{{ OPS_USER }}"
                
                # puccini host
                PUCCINI_HOST = "{{ PUCCINI_FQDN }}"
                PUCCINI_USER = "{{ OPS_USER }}"
                
                # Kibana URL
                KIBANA_JOB_METRICS_URL = "https://{{ METRICS_FQDN }}/metrics/#/dashboard/elasticsearch/Job%20Metrics"
                KIBANA_PROV_METRICS_URL = "https://{{ METRICS_FQDN }}/metrics/#/dashboard/elasticsearch/Provenance%20Metrics"
                KIBANA_INSTANCE_STATS_URL = "https://{{ METRICS_FQDN }}/metrics/#/dashboard/elasticsearch/Worker%20Metrics"
                
                # Flower URL
                FLOWER_URL = "http://{{ MOZART_FQDN }}:5555"
                
                # RabbitMQ Admin URL
                RABBITMQ_ADMIN_URL = "http://rabbitmq:15672"
                RABBITMQ_ADMIN_API = "http://rabbitmq:15672"
                
                # System protected queue
                PROTECTED_QUEUES = ["{{ SYSTEM_JOBS_QUEUE }}"]
                
                JOB_SUBMISSION_JOB_SPEC = "{{ LIGHTWEIGHT_JOBS_SPEC }}"
                JOB_SUBMISSION_QUEUE = "{{ SYSTEM_JOBS_QUEUE }}"
                
                # ES plugins
                # ES_HEAD_URL = "http://{{ MOZART_ES_FQDN }}:9200/_plugin/head"
                # ES_KOPF_URL = "http://{{ MOZART_ES_FQDN }}:9200/_plugin/kopf"
                
                # value needed to generate Jenkins job name
                # VENUE = "{{ VENUE }}"
                VENUE = "unity-demo"
                
                # jenkins
                # JENKINS_ENABLED = {{ JENKINS_ENABLED or False }}
                JENKINS_ENABLED = False
                JENKINS_HOST = "{{ JENKINS_HOST }}"
                JENKINS_USER = "{{ JENKINS_API_USER }}"
                JENKINS_API_KEY = "{{ JENKINS_API_KEY }}"
            EOT
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "mozart-settings"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_config_map.netrc will be created
  + resource "kubernetes_config_map" "netrc" {
      + data = {
          + ".netrc" = <<-EOT
                machine rabbitmq
                login guest
                password guest
            EOT
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "netrc"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_config_map.supervisord-job-worker will be created
  + resource "kubernetes_config_map" "supervisord-job-worker" {
      + data = {
          + "supervisord.conf" = <<-EOT
                [supervisord]
                
                [program:factotum-job_worker-small]
                directory=/home/ops/hysds
                environment=HYSDS_ROOT_WORK_DIR="/private/tmp/data/work",
                            HYSDS_DATASETS_CFG="/home/ops/datasets.json"
                command=celery --app=hysds worker --concurrency=1 --loglevel=INFO -Q factotum-job_worker-small -n %(program_name)s.%(process_num)02d.%%h -O fair --without-mingle --without-gossip --heartbeat-interval=60
                process_name=%(program_name)s-%(process_num)02d
                priority=1
                numprocs=1
                numprocs_start=0
                redirect_stderr=true
                stdout_logfile=/home/ops/%(program_name)s-%(process_num)02d.log
                stdout_logfile_maxbytes=20MB
                stdout_logfile_backups=1
                startsecs=10
                
                [program:factotum-job_worker-large]
                directory=/home/ops/hysds
                environment=HYSDS_ROOT_WORK_DIR="/private/tmp/data/work",
                            HYSDS_DATASETS_CFG="/home/ops/datasets.json"
                command=celery --app=hysds worker --concurrency=1 --loglevel=INFO -Q factotum-job_worker-large -n %(program_name)s.%(process_num)02d.%%h -O fair --without-mingle --without-gossip --heartbeat-interval=60
                process_name=%(program_name)s-%(process_num)02d
                priority=1
                numprocs=1
                numprocs_start=0
                redirect_stderr=true
                stdout_logfile=/home/ops/%(program_name)s-%(process_num)02d.log
                stdout_logfile_maxbytes=20MB
                stdout_logfile_backups=1
                startsecs=10
                
                [program:system-jobs-queue]
                directory=/home/ops/hysds
                environment=HYSDS_ROOT_WORK_DIR="/private/tmp/data/work",
                            HYSDS_DATASETS_CFG="/home/ops/datasets.json"
                command=celery --app=hysds worker --concurrency=1 --loglevel=INFO -Q system-jobs-queue -n %(program_name)s.%(process_num)02d.%%h -O fair --without-mingle --without-gossip --heartbeat-interval=60
                process_name=%(program_name)s-%(process_num)02d
                priority=1
                numprocs=2
                numprocs_start=0
                redirect_stderr=true
                stdout_logfile=/home/ops/%(program_name)s-%(process_num)02d.log
                stdout_logfile_maxbytes=20MB
                stdout_logfile_backups=1
                startsecs=10
            EOT
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "supervisord-job-worker"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_config_map.supervisord-orchestrator will be created
  + resource "kubernetes_config_map" "supervisord-orchestrator" {
      + data = {
          + "supervisord.conf" = <<-EOT
                [supervisord]
                
                [program:orchestrator_datasets]
                directory=/home/ops/hysds
                environment=HYSDS_ORCHESTRATOR_CFG="/home/ops/hysds/configs/orchestrator/orchestrator_datasets.json",
                            HYSDS_JOB_CREATORS_DIR="/home/ops/hysds/scripts/job_creators"
                command=celery --app=hysds worker --concurrency=1 --loglevel=INFO -Q dataset_processed -n %(program_name)s.%(process_num)02d.%%h -O fair --without-mingle --without-gossip --heartbeat-interval=60
                process_name=%(program_name)s-%(process_num)02d
                priority=1
                numprocs=2
                numprocs_start=0
                redirect_stderr=true
                stdout_logfile=/home/ops/%(program_name)s-%(process_num)02d.log
                stdout_logfile_maxbytes=20MB
                stdout_logfile_backups=1
                startsecs=10
                
                [program:orchestrator_jobs]
                directory=/home/ops/hysds
                environment=HYSDS_ORCHESTRATOR_CFG="/home/ops/hysds/configs/orchestrator/orchestrator_jobs.json",
                            HYSDS_JOB_CREATORS_DIR="/home/ops/hysds/scripts/job_creators"
                command=celery --app=hysds worker --concurrency=1 --loglevel=INFO -Q jobs_processed -n %(program_name)s.%(process_num)02d.%%h -O fair --without-mingle --without-gossip --heartbeat-interval=60
                process_name=%(program_name)s-%(process_num)02d
                priority=1
                numprocs=2
                numprocs_start=0
                redirect_stderr=true
                stdout_logfile=/home/ops/%(program_name)s-%(process_num)02d.log
                stdout_logfile_maxbytes=20MB
                stdout_logfile_backups=1
                startsecs=10
                
                [program:on_demand_job]
                directory=/home/ops/hysds
                command=celery --app=hysds worker --concurrency=1 --loglevel=INFO -Q on_demand_job -n %(program_name)s.%(process_num)02d.%%h -O fair --without-mingle --without-gossip --heartbeat-interval=60
                process_name=%(program_name)s-%(process_num)02d
                priority=1
                numprocs=2
                numprocs_start=0
                redirect_stderr=true
                stdout_logfile=/home/ops/%(program_name)s-%(process_num)02d.log
                stdout_logfile_maxbytes=20MB
                stdout_logfile_backups=1
                startsecs=10
                
                [program:on_demand_dataset]
                directory=/home/ops/hysds
                command=celery --app=hysds worker --concurrency=1 --loglevel=INFO -Q on_demand_dataset -n %(program_name)s.%(process_num)02d.%%h -O fair --without-mingle --without-gossip --heartbeat-interval=60
                process_name=%(program_name)s-%(process_num)02d
                priority=1
                numprocs=2
                numprocs_start=0
                redirect_stderr=true
                stdout_logfile=/home/ops/%(program_name)s-%(process_num)02d.log
                stdout_logfile_maxbytes=20MB
                stdout_logfile_backups=1
                startsecs=10
            EOT
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "supervisord-orchestrator"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_config_map.supervisord-user-rules will be created
  + resource "kubernetes_config_map" "supervisord-user-rules" {
      + data = {
          + "supervisord.conf" = <<-EOT
                [supervisord]
                
                [program:user_rules_job]
                directory=/home/ops/hysds
                command=celery --app=hysds worker --concurrency=1 --loglevel=INFO -Q user_rules_job -n %(program_name)s.%(process_num)02d.%%h -O fair --without-mingle --without-gossip --heartbeat-interval=60
                process_name=%(program_name)s-%(process_num)02d
                priority=1
                numprocs=2
                numprocs_start=0
                redirect_stderr=true
                stdout_logfile=/home/ops/%(program_name)s-%(process_num)02d.log
                stdout_logfile_maxbytes=20MB
                stdout_logfile_backups=1
                startsecs=10
                
                [program:user_rules_dataset]
                directory=/home/ops/hysds
                command=celery --app=hysds worker --concurrency=1 --loglevel=INFO -Q user_rules_dataset -n %(program_name)s.%(process_num)02d.%%h -O fair --without-mingle --without-gossip --heartbeat-interval=60
                process_name=%(program_name)s-%(process_num)02d
                priority=1
                numprocs=2
                numprocs_start=0
                redirect_stderr=true
                stdout_logfile=/home/ops/%(program_name)s-%(process_num)02d.log
                stdout_logfile_maxbytes=20MB
                stdout_logfile_backups=1
                startsecs=10
            EOT
        }
      + id   = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "supervisord-user-rules"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_deployment.factotum-job-worker will be created
  + resource "kubernetes_deployment" "factotum-job-worker" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "factotum-job-worker"
            }
          + name             = "factotum-job-worker"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = (known after apply)
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "factotum-job-worker"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "factotum-job-worker"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + command                    = [
                          + "supervisord",
                          + "--nodaemon",
                        ]
                      + image                      = "factotum:unity-v0.0.1"
                      + image_pull_policy          = (known after apply)
                      + name                       = "factotum-job-worker"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/var/run/docker.sock"
                          + mount_propagation = "None"
                          + name              = "docker-sock"
                          + read_only         = false
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/factotum/celeryconfig.py"
                          + mount_propagation = "None"
                          + name              = "celeryconfig"
                          + read_only         = false
                          + sub_path          = "celeryconfig.py"
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/datasets.json"
                          + mount_propagation = "None"
                          + name              = "datasets"
                          + read_only         = false
                          + sub_path          = "datasets.json"
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/supervisord.conf"
                          + mount_propagation = "None"
                          + name              = "supervisord-job-worker"
                          + read_only         = false
                          + sub_path          = "supervisord.conf"
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/.aws/credentials"
                          + mount_propagation = "None"
                          + name              = "aws-credentials"
                          + read_only         = false
                          + sub_path          = "aws-credentials"
                        }
                      + volume_mount {
                          + mount_path        = "/private/tmp/data"
                          + mount_propagation = "None"
                          + name              = "data-work"
                          + read_only         = false
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + init_container {
                      + command                    = [
                          + "/bin/sh",
                          + "-c",
                          + "chmod 777 /var/run/docker.sock; chown -R 1000:1000 /private/tmp/data;",
                        ]
                      + image                      = "k8s.gcr.io/busybox"
                      + image_pull_policy          = (known after apply)
                      + name                       = "changeume-ownership"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/var/run/docker.sock"
                          + mount_propagation = "None"
                          + name              = "docker-sock"
                          + read_only         = false
                        }
                      + volume_mount {
                          + mount_path        = "/private/tmp/data"
                          + mount_propagation = "None"
                          + name              = "data-work"
                          + read_only         = false
                        }
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + volume {
                      + name = "docker-sock"

                      + host_path {
                          + path = "/var/run/docker.sock"
                        }
                    }
                  + volume {
                      + name = "celeryconfig"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "celeryconfig"
                        }
                    }
                  + volume {
                      + name = "datasets"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "datasets"
                        }
                    }
                  + volume {
                      + name = "supervisord-job-worker"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "supervisord-job-worker"
                        }
                    }
                  + volume {
                      + name = "aws-credentials"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "aws-credentials"
                        }
                    }
                  + volume {
                      + name = "data-work"

                      + host_path {
                          + path = "/private/tmp/data"
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.grq2 will be created
  + resource "kubernetes_deployment" "grq2" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "grq2"
            }
          + name             = "grq2"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = (known after apply)
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "grq2"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "grq2"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                      = "hysds-grq2:unity-v0.0.1"
                      + image_pull_policy          = (known after apply)
                      + name                       = "grq2"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + port {
                          + container_port = 8878
                          + name           = "grq2"
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/home/ops/grq2/settings.cfg"
                          + mount_propagation = "None"
                          + name              = "grq2-settings"
                          + read_only         = false
                          + sub_path          = "settings.cfg"
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/grq2/celeryconfig.py"
                          + mount_propagation = "None"
                          + name              = "celeryconfig"
                          + read_only         = false
                          + sub_path          = "celeryconfig.py"
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/.netrc"
                          + mount_propagation = "None"
                          + name              = "netrc"
                          + read_only         = false
                          + sub_path          = ".netrc"
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + volume {
                      + name = "grq2-settings"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "grq2-settings"
                        }
                    }
                  + volume {
                      + name = "celeryconfig"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "celeryconfig"
                        }
                    }
                  + volume {
                      + name = "netrc"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "netrc"
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.hysds-ui will be created
  + resource "kubernetes_deployment" "hysds-ui" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + name             = "hysds-ui"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = (known after apply)
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "hysds-ui"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "hysds-ui"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                      = "hysds-ui:unity-v0.0.1"
                      + image_pull_policy          = (known after apply)
                      + name                       = "hysds-ui"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + port {
                          + container_port = 80
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + volume {
                      + name = (known after apply)

                      + aws_elastic_block_store {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + azure_disk {
                          + caching_mode  = (known after apply)
                          + data_disk_uri = (known after apply)
                          + disk_name     = (known after apply)
                          + fs_type       = (known after apply)
                          + kind          = (known after apply)
                          + read_only     = (known after apply)
                        }

                      + azure_file {
                          + read_only        = (known after apply)
                          + secret_name      = (known after apply)
                          + secret_namespace = (known after apply)
                          + share_name       = (known after apply)
                        }

                      + ceph_fs {
                          + monitors    = (known after apply)
                          + path        = (known after apply)
                          + read_only   = (known after apply)
                          + secret_file = (known after apply)
                          + user        = (known after apply)

                          + secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }
                        }

                      + cinder {
                          + fs_type   = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + config_map {
                          + default_mode = (known after apply)
                          + name         = (known after apply)
                          + optional     = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + csi {
                          + driver            = (known after apply)
                          + fs_type           = (known after apply)
                          + read_only         = (known after apply)
                          + volume_attributes = (known after apply)
                          + volume_handle     = (known after apply)

                          + controller_expand_secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }

                          + controller_publish_secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }

                          + node_publish_secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }

                          + node_stage_secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }
                        }

                      + downward_api {
                          + default_mode = (known after apply)

                          + items {
                              + mode = (known after apply)
                              + path = (known after apply)

                              + field_ref {
                                  + api_version = (known after apply)
                                  + field_path  = (known after apply)
                                }

                              + resource_field_ref {
                                  + container_name = (known after apply)
                                  + divisor        = (known after apply)
                                  + resource       = (known after apply)
                                }
                            }
                        }

                      + empty_dir {
                          + medium     = (known after apply)
                          + size_limit = (known after apply)
                        }

                      + fc {
                          + fs_type      = (known after apply)
                          + lun          = (known after apply)
                          + read_only    = (known after apply)
                          + target_ww_ns = (known after apply)
                        }

                      + flex_volume {
                          + driver    = (known after apply)
                          + fs_type   = (known after apply)
                          + options   = (known after apply)
                          + read_only = (known after apply)

                          + secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }
                        }

                      + flocker {
                          + dataset_name = (known after apply)
                          + dataset_uuid = (known after apply)
                        }

                      + gce_persistent_disk {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + pd_name   = (known after apply)
                          + read_only = (known after apply)
                        }

                      + git_repo {
                          + directory  = (known after apply)
                          + repository = (known after apply)
                          + revision   = (known after apply)
                        }

                      + glusterfs {
                          + endpoints_name = (known after apply)
                          + path           = (known after apply)
                          + read_only      = (known after apply)
                        }

                      + host_path {
                          + path = (known after apply)
                          + type = (known after apply)
                        }

                      + iscsi {
                          + fs_type         = (known after apply)
                          + iqn             = (known after apply)
                          + iscsi_interface = (known after apply)
                          + lun             = (known after apply)
                          + read_only       = (known after apply)
                          + target_portal   = (known after apply)
                        }

                      + local {
                          + path = (known after apply)
                        }

                      + nfs {
                          + path      = (known after apply)
                          + read_only = (known after apply)
                          + server    = (known after apply)
                        }

                      + persistent_volume_claim {
                          + claim_name = (known after apply)
                          + read_only  = (known after apply)
                        }

                      + photon_persistent_disk {
                          + fs_type = (known after apply)
                          + pd_id   = (known after apply)
                        }

                      + projected {
                          + default_mode = (known after apply)

                          + sources {
                              + config_map {
                                  + name     = (known after apply)
                                  + optional = (known after apply)

                                  + items {
                                      + key  = (known after apply)
                                      + mode = (known after apply)
                                      + path = (known after apply)
                                    }
                                }

                              + downward_api {
                                  + items {
                                      + mode = (known after apply)
                                      + path = (known after apply)

                                      + field_ref {
                                          + api_version = (known after apply)
                                          + field_path  = (known after apply)
                                        }

                                      + resource_field_ref {
                                          + container_name = (known after apply)
                                          + divisor        = (known after apply)
                                          + resource       = (known after apply)
                                        }
                                    }
                                }

                              + secret {
                                  + name     = (known after apply)
                                  + optional = (known after apply)

                                  + items {
                                      + key  = (known after apply)
                                      + mode = (known after apply)
                                      + path = (known after apply)
                                    }
                                }

                              + service_account_token {
                                  + audience           = (known after apply)
                                  + expiration_seconds = (known after apply)
                                  + path               = (known after apply)
                                }
                            }
                        }

                      + quobyte {
                          + group     = (known after apply)
                          + read_only = (known after apply)
                          + registry  = (known after apply)
                          + user      = (known after apply)
                          + volume    = (known after apply)
                        }

                      + rbd {
                          + ceph_monitors = (known after apply)
                          + fs_type       = (known after apply)
                          + keyring       = (known after apply)
                          + rados_user    = (known after apply)
                          + rbd_image     = (known after apply)
                          + rbd_pool      = (known after apply)
                          + read_only     = (known after apply)

                          + secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }
                        }

                      + secret {
                          + default_mode = (known after apply)
                          + optional     = (known after apply)
                          + secret_name  = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + vsphere_volume {
                          + fs_type     = (known after apply)
                          + volume_path = (known after apply)
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.logstash will be created
  + resource "kubernetes_deployment" "logstash" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "logstash"
            }
          + name             = "logstash"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = (known after apply)
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "logstash"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "logstash"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + args                       = [
                          + "-f",
                          + "/usr/share/logstash/logstash.conf",
                        ]
                      + command                    = [
                          + "bin/logstash",
                        ]
                      + image                      = "logstash:7.9.3"
                      + image_pull_policy          = (known after apply)
                      + name                       = "logstash"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + port {
                          + container_port = 5044
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/usr/share/logstash/logstash.conf"
                          + mount_propagation = "None"
                          + name              = "logstash-conf"
                          + read_only         = false
                          + sub_path          = "logstash.cfg"
                        }
                      + volume_mount {
                          + mount_path        = "/usr/share/logstash/job_status.template.json"
                          + mount_propagation = "None"
                          + name              = "job-status-mapping"
                          + read_only         = false
                          + sub_path          = "job_status.template.json"
                        }
                      + volume_mount {
                          + mount_path        = "/usr/share/logstash/task_status.template.json"
                          + mount_propagation = "None"
                          + name              = "task-status-mapping"
                          + read_only         = false
                          + sub_path          = "taks_status.template.json"
                        }
                      + volume_mount {
                          + mount_path        = "/usr/share/logstash/event_status.template.json"
                          + mount_propagation = "None"
                          + name              = "event-status-mapping"
                          + read_only         = false
                          + sub_path          = "event_status.template.json"
                        }
                      + volume_mount {
                          + mount_path        = "/usr/share/logstash/worker_status.template.json"
                          + mount_propagation = "None"
                          + name              = "worker-status-mapping"
                          + read_only         = false
                          + sub_path          = "worker_status.template.json"
                        }
                      + volume_mount {
                          + mount_path        = "/usr/share/logstash/config/logstash.yml"
                          + mount_propagation = "None"
                          + name              = "logstash-yml"
                          + read_only         = false
                          + sub_path          = "logstash.yml"
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + volume {
                      + name = "logstash-conf"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "logstash-configs"

                          + items {
                              + key  = "logstash-conf"
                              + path = "logstash.conf"
                            }
                        }
                    }
                  + volume {
                      + name = "job-status-mapping"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "logstash-configs"

                          + items {
                              + key  = "job-status"
                              + path = "job_status.template.json"
                            }
                        }
                    }
                  + volume {
                      + name = "task-status-mapping"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "logstash-configs"

                          + items {
                              + key  = "task-status"
                              + path = "taks_status.template.json"
                            }
                        }
                    }
                  + volume {
                      + name = "event-status-mapping"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "logstash-configs"

                          + items {
                              + key  = "event-status"
                              + path = "event_status.template.json"
                            }
                        }
                    }
                  + volume {
                      + name = "worker-status-mapping"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "logstash-configs"

                          + items {
                              + key  = "worker-status"
                              + path = "worker_status.template.json"
                            }
                        }
                    }
                  + volume {
                      + name = "logstash-yml"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "logstash-configs"

                          + items {
                              + key  = "logstash-yml"
                              + path = "logstash.yml"
                            }
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.minio will be created
  + resource "kubernetes_deployment" "minio" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "minio"
            }
          + name             = "minio"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = (known after apply)
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "minio"
                }
            }

          + strategy {
              + type = "Recreate"

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "minio"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + args                       = [
                          + "server",
                          + "/storage",
                          + "--console-address=:9001",
                        ]
                      + image                      = "minio/minio:latest"
                      + image_pull_policy          = (known after apply)
                      + name                       = "minio"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + env {
                          + name  = "MINIO_ACCESS_KEY"
                          + value = "hysds"
                        }
                      + env {
                          + name  = "MINIO_SECRET_KEY"
                          + value = "password"
                        }

                      + port {
                          + container_port = 9000
                          + host_port      = 9000
                          + protocol       = "TCP"
                        }
                      + port {
                          + container_port = 9001
                          + host_port      = 9001
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/storage"
                          + mount_propagation = "None"
                          + name              = "storage"
                          + read_only         = false
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + volume {
                      + name = "storage"

                      + persistent_volume_claim {
                          + claim_name = "minio-pv-claim"
                          + read_only  = false
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.mozart will be created
  + resource "kubernetes_deployment" "mozart" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "mozart"
            }
          + name             = "mozart"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = (known after apply)
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "mozart"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "mozart"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                      = "hysds-mozart:unity-v0.0.1"
                      + image_pull_policy          = (known after apply)
                      + name                       = "mozart"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + port {
                          + container_port = 8888
                          + name           = "mozart"
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/home/ops/mozart/settings.cfg"
                          + mount_propagation = "None"
                          + name              = "mozart-settings"
                          + read_only         = false
                          + sub_path          = "settings.cfg"
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/mozart/celeryconfig.py"
                          + mount_propagation = "None"
                          + name              = "celeryconfig"
                          + read_only         = false
                          + sub_path          = "celeryconfig.py"
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/.netrc"
                          + mount_propagation = "None"
                          + name              = "netrc"
                          + read_only         = false
                          + sub_path          = ".netrc"
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + volume {
                      + name = "mozart-settings"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "mozart-settings"
                        }
                    }
                  + volume {
                      + name = "celeryconfig"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "celeryconfig"
                        }
                    }
                  + volume {
                      + name = "netrc"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "netrc"
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.orchestrator will be created
  + resource "kubernetes_deployment" "orchestrator" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "orchestrator"
            }
          + name             = "orchestrator"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = (known after apply)
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "orchestrator"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "orchestrator"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + command                    = [
                          + "supervisord",
                          + "--nodaemon",
                        ]
                      + image                      = "hysds-core:unity-v0.0.1"
                      + image_pull_policy          = (known after apply)
                      + name                       = "orchestrator"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/home/ops/factotum/celeryconfig.py"
                          + mount_propagation = "None"
                          + name              = "celeryconfig"
                          + read_only         = false
                          + sub_path          = "celeryconfig.py"
                        }
                      + volume_mount {
                          + mount_path        = "/etc/supervisord.conf"
                          + mount_propagation = "None"
                          + name              = "supervisord-orchestrator"
                          + read_only         = false
                          + sub_path          = "supervisord.conf"
                        }
                      + volume_mount {
                          + mount_path        = "/private/tmp/data"
                          + mount_propagation = "None"
                          + name              = "data-work"
                          + read_only         = false
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + security_context {
                      + run_as_group = "0"
                      + run_as_user  = "0"
                    }

                  + volume {
                      + name = "celeryconfig"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "celeryconfig"
                        }
                    }
                  + volume {
                      + name = "supervisord-orchestrator"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "supervisord-orchestrator"
                        }
                    }
                  + volume {
                      + name = "data-work"

                      + host_path {
                          + path = "/private/tmp/data"
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.redis will be created
  + resource "kubernetes_deployment" "redis" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "redis"
            }
          + name             = "redis"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = (known after apply)
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "redis"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "redis"
                    }
                  + name             = (known after apply)
                  + namespace        = "unity-sps"
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                      = "redis:latest"
                      + image_pull_policy          = "IfNotPresent"
                      + name                       = "redis"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + port {
                          + container_port = 6379
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + volume {
                      + name = (known after apply)

                      + aws_elastic_block_store {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + azure_disk {
                          + caching_mode  = (known after apply)
                          + data_disk_uri = (known after apply)
                          + disk_name     = (known after apply)
                          + fs_type       = (known after apply)
                          + kind          = (known after apply)
                          + read_only     = (known after apply)
                        }

                      + azure_file {
                          + read_only        = (known after apply)
                          + secret_name      = (known after apply)
                          + secret_namespace = (known after apply)
                          + share_name       = (known after apply)
                        }

                      + ceph_fs {
                          + monitors    = (known after apply)
                          + path        = (known after apply)
                          + read_only   = (known after apply)
                          + secret_file = (known after apply)
                          + user        = (known after apply)

                          + secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }
                        }

                      + cinder {
                          + fs_type   = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + config_map {
                          + default_mode = (known after apply)
                          + name         = (known after apply)
                          + optional     = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + csi {
                          + driver            = (known after apply)
                          + fs_type           = (known after apply)
                          + read_only         = (known after apply)
                          + volume_attributes = (known after apply)
                          + volume_handle     = (known after apply)

                          + controller_expand_secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }

                          + controller_publish_secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }

                          + node_publish_secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }

                          + node_stage_secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }
                        }

                      + downward_api {
                          + default_mode = (known after apply)

                          + items {
                              + mode = (known after apply)
                              + path = (known after apply)

                              + field_ref {
                                  + api_version = (known after apply)
                                  + field_path  = (known after apply)
                                }

                              + resource_field_ref {
                                  + container_name = (known after apply)
                                  + divisor        = (known after apply)
                                  + resource       = (known after apply)
                                }
                            }
                        }

                      + empty_dir {
                          + medium     = (known after apply)
                          + size_limit = (known after apply)
                        }

                      + fc {
                          + fs_type      = (known after apply)
                          + lun          = (known after apply)
                          + read_only    = (known after apply)
                          + target_ww_ns = (known after apply)
                        }

                      + flex_volume {
                          + driver    = (known after apply)
                          + fs_type   = (known after apply)
                          + options   = (known after apply)
                          + read_only = (known after apply)

                          + secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }
                        }

                      + flocker {
                          + dataset_name = (known after apply)
                          + dataset_uuid = (known after apply)
                        }

                      + gce_persistent_disk {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + pd_name   = (known after apply)
                          + read_only = (known after apply)
                        }

                      + git_repo {
                          + directory  = (known after apply)
                          + repository = (known after apply)
                          + revision   = (known after apply)
                        }

                      + glusterfs {
                          + endpoints_name = (known after apply)
                          + path           = (known after apply)
                          + read_only      = (known after apply)
                        }

                      + host_path {
                          + path = (known after apply)
                          + type = (known after apply)
                        }

                      + iscsi {
                          + fs_type         = (known after apply)
                          + iqn             = (known after apply)
                          + iscsi_interface = (known after apply)
                          + lun             = (known after apply)
                          + read_only       = (known after apply)
                          + target_portal   = (known after apply)
                        }

                      + local {
                          + path = (known after apply)
                        }

                      + nfs {
                          + path      = (known after apply)
                          + read_only = (known after apply)
                          + server    = (known after apply)
                        }

                      + persistent_volume_claim {
                          + claim_name = (known after apply)
                          + read_only  = (known after apply)
                        }

                      + photon_persistent_disk {
                          + fs_type = (known after apply)
                          + pd_id   = (known after apply)
                        }

                      + projected {
                          + default_mode = (known after apply)

                          + sources {
                              + config_map {
                                  + name     = (known after apply)
                                  + optional = (known after apply)

                                  + items {
                                      + key  = (known after apply)
                                      + mode = (known after apply)
                                      + path = (known after apply)
                                    }
                                }

                              + downward_api {
                                  + items {
                                      + mode = (known after apply)
                                      + path = (known after apply)

                                      + field_ref {
                                          + api_version = (known after apply)
                                          + field_path  = (known after apply)
                                        }

                                      + resource_field_ref {
                                          + container_name = (known after apply)
                                          + divisor        = (known after apply)
                                          + resource       = (known after apply)
                                        }
                                    }
                                }

                              + secret {
                                  + name     = (known after apply)
                                  + optional = (known after apply)

                                  + items {
                                      + key  = (known after apply)
                                      + mode = (known after apply)
                                      + path = (known after apply)
                                    }
                                }

                              + service_account_token {
                                  + audience           = (known after apply)
                                  + expiration_seconds = (known after apply)
                                  + path               = (known after apply)
                                }
                            }
                        }

                      + quobyte {
                          + group     = (known after apply)
                          + read_only = (known after apply)
                          + registry  = (known after apply)
                          + user      = (known after apply)
                          + volume    = (known after apply)
                        }

                      + rbd {
                          + ceph_monitors = (known after apply)
                          + fs_type       = (known after apply)
                          + keyring       = (known after apply)
                          + rados_user    = (known after apply)
                          + rbd_image     = (known after apply)
                          + rbd_pool      = (known after apply)
                          + read_only     = (known after apply)

                          + secret_ref {
                              + name      = (known after apply)
                              + namespace = (known after apply)
                            }
                        }

                      + secret {
                          + default_mode = (known after apply)
                          + optional     = (known after apply)
                          + secret_name  = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + vsphere_volume {
                          + fs_type     = (known after apply)
                          + volume_path = (known after apply)
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.user-rules will be created
  + resource "kubernetes_deployment" "user-rules" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "user-rules"
            }
          + name             = "user-rules"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = (known after apply)
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app" = "user-rules"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "user-rules"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + command                    = [
                          + "supervisord",
                          + "--nodaemon",
                        ]
                      + image                      = "hysds-core:unity-v0.0.1"
                      + image_pull_policy          = (known after apply)
                      + name                       = "user-rules"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/home/ops/factotum/celeryconfig.py"
                          + mount_propagation = "None"
                          + name              = "celeryconfig"
                          + read_only         = false
                          + sub_path          = "celeryconfig.py"
                        }
                      + volume_mount {
                          + mount_path        = "/etc/supervisord.conf"
                          + mount_propagation = "None"
                          + name              = "supervisord-user-rules"
                          + read_only         = false
                          + sub_path          = "supervisord.conf"
                        }
                      + volume_mount {
                          + mount_path        = "/private/tmp/data"
                          + mount_propagation = "None"
                          + name              = "data-work"
                          + read_only         = false
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + security_context {
                      + run_as_group = "0"
                      + run_as_user  = "0"
                    }

                  + volume {
                      + name = "celeryconfig"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "celeryconfig"
                        }
                    }
                  + volume {
                      + name = "supervisord-user-rules"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "supervisord-user-rules"
                        }
                    }
                  + volume {
                      + name = "data-work"

                      + host_path {
                          + path = "/private/tmp/data"
                        }
                    }
                }
            }
        }
    }

  # kubernetes_job.mc will be created
  + resource "kubernetes_job" "mc" {
      + id                  = (known after apply)
      + wait_for_completion = true

      + metadata {
          + generation       = (known after apply)
          + labels           = (known after apply)
          + name             = "mc"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + completion_mode = (known after apply)
          + completions     = 1
          + parallelism     = 1

          + selector {
              + match_labels = (known after apply)

              + match_expressions {
                  + key      = (known after apply)
                  + operator = (known after apply)
                  + values   = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Never"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                      = "hysds-core:unity-v0.0.1"
                      + image_pull_policy          = (known after apply)
                      + name                       = "publish-aoi"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/home/ops/hysds/celeryconfig.py"
                          + mount_propagation = "None"
                          + name              = "celeryconfig"
                          + read_only         = false
                          + sub_path          = "celeryconfig.py"
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/.aws/credentials"
                          + mount_propagation = "None"
                          + name              = "aws-credentials"
                          + read_only         = false
                          + sub_path          = "aws-credentials"
                        }
                      + volume_mount {
                          + mount_path        = "/home/ops/datasets.json"
                          + mount_propagation = "None"
                          + name              = "datasets"
                          + read_only         = false
                          + sub_path          = "datasets.json"
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + init_container {
                      + command                    = [
                          + "/bin/sh",
                          + "-c",
                          + "while [ $(curl -sw \"%{http_code}\" \"http://minio:9001\" -o /dev/null) -ne 200 ]; do sleep 5; done;",
                        ]
                      + image                      = "k8s.gcr.io/busybox"
                      + image_pull_policy          = (known after apply)
                      + name                       = "ping-minio-server"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }
                    }
                  + init_container {
                      + command                    = [
                          + "/bin/sh",
                          + "-c",
                          + "mc alias set s3 http://minio:9000 hysds password;",
                          + "mc mb s3/datasets;",
                          + "mc policy set public s3/datasets;",
                        ]
                      + image                      = "minio/mc"
                      + image_pull_policy          = (known after apply)
                      + name                       = "minio-setup"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + volume {
                      + name = "celeryconfig"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "celeryconfig"
                        }
                    }
                  + volume {
                      + name = "aws-credentials"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "aws-credentials"
                        }
                    }
                  + volume {
                      + name = "datasets"

                      + config_map {
                          + default_mode = "0644"
                          + name         = "datasets"
                        }
                    }
                }
            }
        }
    }

  # kubernetes_namespace.unity-sps will be created
  + resource "kubernetes_namespace" "unity-sps" {
      + id = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }
    }

  # kubernetes_persistent_volume_claim.minio-pv-claim will be created
  + resource "kubernetes_persistent_volume_claim" "minio-pv-claim" {
      + id               = (known after apply)
      + wait_until_bound = true

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "minio-storage-claim"
            }
          + name             = "minio-pv-claim"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + access_modes       = [
              + "ReadWriteOnce",
            ]
          + storage_class_name = (known after apply)
          + volume_name        = (known after apply)

          + resources {
              + requests = {
                  + "storage" = "20Gi"
                }
            }
        }
    }

  # kubernetes_service.grq2_service will be created
  + resource "kubernetes_service" "grq2_service" {
      + id                     = (known after apply)
      + status                 = (known after apply)
      + wait_for_load_balancer = true

      + metadata {
          + generation       = (known after apply)
          + name             = "grq2"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + health_check_node_port      = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app" = "grq2"
            }
          + session_affinity            = "ClientIP"
          + type                        = "LoadBalancer"

          + port {
              + node_port   = (known after apply)
              + port        = 8878
              + protocol    = "TCP"
              + target_port = "8878"
            }
        }
    }

  # kubernetes_service.hysds-ui_service will be created
  + resource "kubernetes_service" "hysds-ui_service" {
      + id                     = (known after apply)
      + status                 = (known after apply)
      + wait_for_load_balancer = true

      + metadata {
          + generation       = (known after apply)
          + name             = "hysds-ui"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + health_check_node_port      = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app" = "hysds-ui"
            }
          + session_affinity            = "ClientIP"
          + type                        = "LoadBalancer"

          + port {
              + node_port   = 31000
              + port        = 3000
              + protocol    = "TCP"
              + target_port = "80"
            }
        }
    }

  # kubernetes_service.minio_service will be created
  + resource "kubernetes_service" "minio_service" {
      + id                     = (known after apply)
      + status                 = (known after apply)
      + wait_for_load_balancer = true

      + metadata {
          + generation       = (known after apply)
          + name             = "minio"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + health_check_node_port      = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app" = "minio"
            }
          + session_affinity            = "ClientIP"
          + type                        = "LoadBalancer"

          + port {
              + name        = "minio-api"
              + node_port   = (known after apply)
              + port        = 9000
              + protocol    = "TCP"
              + target_port = "9000"
            }
          + port {
              + name        = "minio-interface"
              + node_port   = (known after apply)
              + port        = 9001
              + protocol    = "TCP"
              + target_port = (known after apply)
            }
        }
    }

  # kubernetes_service.mozart_service will be created
  + resource "kubernetes_service" "mozart_service" {
      + id                     = (known after apply)
      + status                 = (known after apply)
      + wait_for_load_balancer = true

      + metadata {
          + generation       = (known after apply)
          + name             = "mozart"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + health_check_node_port      = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app" = "mozart"
            }
          + session_affinity            = "ClientIP"
          + type                        = "LoadBalancer"

          + port {
              + node_port   = (known after apply)
              + port        = 8888
              + protocol    = "TCP"
              + target_port = "8888"
            }
        }
    }

  # kubernetes_service.rabbitmq_mgmt_service will be created
  + resource "kubernetes_service" "rabbitmq_mgmt_service" {
      + id                     = (known after apply)
      + status                 = (known after apply)
      + wait_for_load_balancer = true

      + metadata {
          + generation       = (known after apply)
          + name             = "rabbitmq-mgmt"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + health_check_node_port      = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app" = "rabbitmq"
            }
          + session_affinity            = "ClientIP"
          + type                        = "LoadBalancer"

          + port {
              + name        = "cluster-rpc"
              + node_port   = (known after apply)
              + port        = 15672
              + protocol    = "TCP"
              + target_port = "15672"
            }
        }
    }

  # kubernetes_service.rabbitmq_service will be created
  + resource "kubernetes_service" "rabbitmq_service" {
      + id                     = (known after apply)
      + status                 = (known after apply)
      + wait_for_load_balancer = true

      + metadata {
          + generation       = (known after apply)
          + name             = "rabbitmq"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + health_check_node_port      = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app" = "rabbitmq"
            }
          + session_affinity            = "ClientIP"
          + type                        = "NodePort"

          + port {
              + name        = "epmd"
              + node_port   = (known after apply)
              + port        = 4369
              + protocol    = "TCP"
              + target_port = "4369"
            }
          + port {
              + name        = "listener"
              + node_port   = (known after apply)
              + port        = 5672
              + protocol    = "TCP"
              + target_port = "5672"
            }
          + port {
              + name        = "cluster-rpc"
              + node_port   = (known after apply)
              + port        = 15672
              + protocol    = "TCP"
              + target_port = "15672"
            }
        }
    }

  # kubernetes_service.redis_service will be created
  + resource "kubernetes_service" "redis_service" {
      + id                     = (known after apply)
      + status                 = (known after apply)
      + wait_for_load_balancer = true

      + metadata {
          + generation       = (known after apply)
          + name             = "redis"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + health_check_node_port      = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app" = "redis"
            }
          + session_affinity            = "ClientIP"
          + type                        = "NodePort"

          + port {
              + node_port   = (known after apply)
              + port        = 6379
              + protocol    = "TCP"
              + target_port = "6379"
            }
        }
    }

  # kubernetes_stateful_set.rabbitmq_statefulset will be created
  + resource "kubernetes_stateful_set" "rabbitmq_statefulset" {
      + id               = (known after apply)
      + wait_for_rollout = true

      + metadata {
          + generation       = (known after apply)
          + name             = "rabbitmq"
          + namespace        = "unity-sps"
          + resource_version = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + pod_management_policy  = (known after apply)
          + replicas               = (known after apply)
          + revision_history_limit = (known after apply)
          + service_name           = "rabbitmq"

          + selector {
              + match_labels = {
                  + "app" = "rabbitmq"
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app" = "rabbitmq"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + automount_service_account_token  = true
                  + dns_policy                       = "ClusterFirst"
                  + enable_service_links             = true
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                      = "rabbitmq:3-management"
                      + image_pull_policy          = (known after apply)
                      + name                       = "rabbitmq"
                      + stdin                      = false
                      + stdin_once                 = false
                      + termination_message_path   = "/dev/termination-log"
                      + termination_message_policy = (known after apply)
                      + tty                        = false

                      + env {
                          + name  = "RABBITMQ_ERLANG_COOKIE"
                          + value = "1WqgH8N2v1qDBDZDbNy8Bg9IkPWLEpu79m6q+0t36lQ="
                        }

                      + resources {
                          + limits   = (known after apply)
                          + requests = (known after apply)
                        }

                      + volume_mount {
                          + mount_path        = "/var/lib/rabbitmq"
                          + mount_propagation = "None"
                          + name              = "rabbitmq-data"
                          + read_only         = false
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + readiness_gate {
                      + condition_type = (known after apply)
                    }

                  + volume {
                      + name = "rabbitmq-data"

                      + host_path {
                          + path = "/data/rabbitmq"
                          + type = "DirectoryOrCreate"
                        }
                    }
                }
            }
        }
    }

Plan: 32 to add, 0 to change, 0 to destroy.
kubernetes_namespace.unity-sps: Creating...
kubernetes_namespace.unity-sps: Creation complete after 0s [id=unity-sps]
kubernetes_config_map.mozart-settings: Creating...
kubernetes_service.rabbitmq_service: Creating...
kubernetes_deployment.user-rules: Creating...
kubernetes_deployment.mozart: Creating...
kubernetes_config_map.supervisord-job-worker: Creating...
kubernetes_config_map.logstash-configs: Creating...
kubernetes_deployment.logstash: Creating...
kubernetes_deployment.hysds-ui: Creating...
kubernetes_deployment.factotum-job-worker: Creating...
kubernetes_config_map.mozart-settings: Creation complete after 1s [id=unity-sps/mozart-settings]
kubernetes_config_map.supervisord-orchestrator: Creating...
kubernetes_config_map.supervisord-job-worker: Creation complete after 0s [id=unity-sps/supervisord-job-worker]
kubernetes_deployment.minio: Creating...
kubernetes_config_map.logstash-configs: Creation complete after 0s [id=unity-sps/logstash-configs]
kubernetes_config_map.supervisord-user-rules: Creating...
helm_release.grq2-es: Creating...
kubernetes_config_map.supervisord-orchestrator: Creation complete after 1s [id=unity-sps/supervisord-orchestrator]
kubernetes_service.mozart_service: Creating...
kubernetes_config_map.supervisord-user-rules: Creation complete after 1s [id=unity-sps/supervisord-user-rules]
kubernetes_config_map.celeryconfig: Creating...
kubernetes_service.rabbitmq_service: Creation complete after 2s [id=unity-sps/rabbitmq]
kubernetes_persistent_volume_claim.minio-pv-claim: Creating...
kubernetes_config_map.celeryconfig: Creation complete after 0s [id=unity-sps/celeryconfig]
kubernetes_config_map.aws-credentials: Creating...
kubernetes_config_map.aws-credentials: Creation complete after 1s [id=unity-sps/aws-credentials]
kubernetes_config_map.netrc: Creating...
kubernetes_config_map.netrc: Creation complete after 0s [id=unity-sps/netrc]
kubernetes_config_map.datasets: Creating...
kubernetes_service.mozart_service: Creation complete after 1s [id=unity-sps/mozart]
kubernetes_stateful_set.rabbitmq_statefulset: Creating...
kubernetes_config_map.datasets: Creation complete after 1s [id=unity-sps/datasets]
kubernetes_service.grq2_service: Creating...
kubernetes_persistent_volume_claim.minio-pv-claim: Creation complete after 2s [id=unity-sps/minio-pv-claim]
kubernetes_deployment.orchestrator: Creating...
kubernetes_service.grq2_service: Creation complete after 1s [id=unity-sps/grq2]
kubernetes_service.hysds-ui_service: Creating...
kubernetes_service.hysds-ui_service: Creation complete after 1s [id=unity-sps/hysds-ui]
kubernetes_service.rabbitmq_mgmt_service: Creating...
kubernetes_service.rabbitmq_mgmt_service: Creation complete after 1s [id=unity-sps/rabbitmq-mgmt]
kubernetes_service.redis_service: Creating...
kubernetes_service.redis_service: Creation complete after 0s [id=unity-sps/redis]
kubernetes_service.minio_service: Creating...
kubernetes_service.minio_service: Creation complete after 1s [id=unity-sps/minio]
kubernetes_deployment.grq2: Creating...
kubernetes_deployment.user-rules: Still creating... [10s elapsed]
kubernetes_deployment.mozart: Still creating... [10s elapsed]
kubernetes_deployment.hysds-ui: Still creating... [10s elapsed]
kubernetes_deployment.logstash: Still creating... [10s elapsed]
kubernetes_deployment.factotum-job-worker: Still creating... [10s elapsed]
kubernetes_deployment.minio: Still creating... [10s elapsed]
helm_release.grq2-es: Still creating... [10s elapsed]
kubernetes_deployment.orchestrator: Creation complete after 8s [id=unity-sps/orchestrator]
kubernetes_deployment.redis: Creating...
kubernetes_stateful_set.rabbitmq_statefulset: Still creating... [10s elapsed]
kubernetes_deployment.minio: Creation complete after 16s [id=unity-sps/minio]
kubernetes_config_map.grq2-settings: Creating...
kubernetes_deployment.hysds-ui: Creation complete after 16s [id=unity-sps/hysds-ui]
kubernetes_config_map.grq2-settings: Creation complete after 0s [id=unity-sps/grq2-settings]
kubernetes_job.mc: Creating...
kubernetes_deployment.logstash: Creation complete after 16s [id=unity-sps/logstash]
kubernetes_deployment.user-rules: Creation complete after 17s [id=unity-sps/user-rules]
kubernetes_deployment.mozart: Creation complete after 17s [id=unity-sps/mozart]
kubernetes_deployment.factotum-job-worker: Creation complete after 17s [id=unity-sps/factotum-job-worker]
helm_release.mozart-es: Creating...
kubernetes_deployment.grq2: Still creating... [10s elapsed]
kubernetes_stateful_set.rabbitmq_statefulset: Creation complete after 16s [id=unity-sps/rabbitmq]
kubernetes_deployment.redis: Creation complete after 9s [id=unity-sps/redis]
helm_release.grq2-es: Still creating... [20s elapsed]
kubernetes_job.mc: Still creating... [10s elapsed]
helm_release.mozart-es: Still creating... [10s elapsed]
kubernetes_deployment.grq2: Still creating... [20s elapsed]
helm_release.grq2-es: Still creating... [30s elapsed]
kubernetes_job.mc: Creation complete after 16s [id=unity-sps/mc]
kubernetes_deployment.grq2: Creation complete after 26s [id=unity-sps/grq2]
helm_release.mozart-es: Still creating... [20s elapsed]
helm_release.grq2-es: Still creating... [40s elapsed]
helm_release.mozart-es: Still creating... [30s elapsed]
helm_release.grq2-es: Still creating... [50s elapsed]
helm_release.mozart-es: Still creating... [40s elapsed]
helm_release.grq2-es: Still creating... [1m0s elapsed]
helm_release.mozart-es: Still creating... [50s elapsed]
helm_release.grq2-es: Still creating... [1m10s elapsed]
helm_release.mozart-es: Still creating... [1m0s elapsed]
helm_release.grq2-es: Still creating... [1m20s elapsed]
helm_release.mozart-es: Still creating... [1m10s elapsed]
helm_release.grq2-es: Still creating... [1m30s elapsed]
helm_release.mozart-es: Still creating... [1m20s elapsed]
helm_release.grq2-es: Creation complete after 1m38s [id=grq2-es]
helm_release.mozart-es: Still creating... [1m30s elapsed]
helm_release.mozart-es: Creation complete after 1m35s [id=mozart-es]

Apply complete! Resources: 32 added, 0 changed, 0 destroyed.
